// This file was generated by stellar_contract_bindings v0.4.1b0 and stellar_sdk v13.0.0b0.

import 'dart:typed_data';
import 'package:stellar_flutter_sdk/stellar_flutter_sdk.dart';

/// Kind enum for AuthContractDataKey
enum AuthContractDataKeyKind {
  Counter('Counter');

  final String value;
  
  const AuthContractDataKeyKind(this.value);
  
  factory AuthContractDataKeyKind.fromValue(String value) {
    return AuthContractDataKeyKind.values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw ArgumentError('Unknown AuthContractDataKeyKind value: $value'),
    );
  }
}

/// AuthContractDataKey union
class AuthContractDataKey {
  final AuthContractDataKeyKind kind;
  final Address? counter;

  const AuthContractDataKey._({
    required this.kind,
    this.counter,
  });
  factory AuthContractDataKey.counter(Address value) {
    return AuthContractDataKey._(
      kind: AuthContractDataKeyKind.Counter,
      counter: value,
    );
  }

  XdrSCVal toScVal() {
    switch (kind) {
      case AuthContractDataKeyKind.Counter:
        return XdrSCVal.forVec([
          XdrSCVal.forSymbol(kind.value),
          counter!.toXdrSCVal(),
        ]);
    }
  }

  factory AuthContractDataKey.fromScVal(XdrSCVal val) {
    final vec = val.vec!;
    final kind = AuthContractDataKeyKind.fromValue(vec[0].sym!.toString());
    
    switch (kind) {
      case AuthContractDataKeyKind.Counter:
        return AuthContractDataKey.counter(
          Address.fromXdrSCVal(vec[1])
        );
    }
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! AuthContractDataKey) return false;
    if (kind != other.kind) return false;
    
    switch (kind) {
      case AuthContractDataKeyKind.Counter:
        return counter == other.counter;
    }
  }

  @override
  int get hashCode {
    switch (kind) {
      case AuthContractDataKeyKind.Counter:
        return Object.hash(kind, counter);
    }
  }
}

/// Client for interacting with the AuthContract contract
class AuthContract {
  /// The underlying SorobanClient instance
  final SorobanClient _client;

  /// Creates a new AuthContract for the given contract ID
  static Future<AuthContract> forContractId({
    required KeyPair sourceAccountKeyPair,
    required String contractId,
    required Network network,
    required String rpcUrl,
    bool enableServerLogging = false,
  }) async {
    final options = ClientOptions(
      sourceAccountKeyPair: sourceAccountKeyPair,
      contractId: contractId,
      network: network,
      rpcUrl: rpcUrl,
      enableServerLogging: enableServerLogging,
    );
    
    final client = await SorobanClient.forClientOptions(options: options);
    return AuthContract._(client);
  }
  
  /// Private constructor that wraps a SorobanClient
  AuthContract._(this._client);

  /// Gets the contract ID
  String getContractId() => _client.getContractId();

  /// Gets the client options
  ClientOptions getOptions() => _client.getOptions();

  /// Gets the contract specification
  ContractSpec getContractSpec() => _client.getContractSpec();
  
  /// Increment increments a counter for the user, and returns the value.
  Future<int> increment({
    required Address user,
    required int value,
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
      user.toXdrSCVal(),
      XdrSCVal.forU32(value),
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'increment',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
    return result.u32!.uint32;
  }
  
  /// Builds an AssembledTransaction for the increment method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildIncrementTx({
    required Address user,
    required int value,
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
      user.toXdrSCVal(),
      XdrSCVal.forU32(value),
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'increment',
      args: args,
      methodOptions: methodOptions,
    );
  }
}