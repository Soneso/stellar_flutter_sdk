// This file was generated by stellar_contract_bindings v0.5.0b0 and stellar_sdk v13.0.0.

import 'dart:typed_data';
import 'package:stellar_flutter_sdk/stellar_flutter_sdk.dart';

/// Client for interacting with the AtomicSwapContract contract
class AtomicSwapContract {
  /// The underlying SorobanClient instance
  final SorobanClient _client;

  /// Creates a new AtomicSwapContract for the given contract ID
  static Future<AtomicSwapContract> forContractId({
    required KeyPair sourceAccountKeyPair,
    required String contractId,
    required Network network,
    required String rpcUrl,
    bool enableServerLogging = false,
  }) async {
    final options = ClientOptions(
      sourceAccountKeyPair: sourceAccountKeyPair,
      contractId: contractId,
      network: network,
      rpcUrl: rpcUrl,
      enableServerLogging: enableServerLogging,
    );
    
    final client = await SorobanClient.forClientOptions(options: options);
    return AtomicSwapContract._(client);
  }
  
  /// Private constructor that wraps a SorobanClient
  AtomicSwapContract._(this._client);

  /// Gets the contract ID
  String getContractId() => _client.getContractId();

  /// Gets the client options
  ClientOptions getOptions() => _client.getOptions();

  /// Gets the contract specification
  ContractSpec getContractSpec() => _client.getContractSpec();
  
  /// Invokes the swap method
  Future<void> swap({
    required Address a,
    required Address b,
    required Address tokenA,
    required Address tokenB,
    required BigInt amountA,
    required BigInt minBForA,
    required BigInt amountB,
    required BigInt minAForB,
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
      a.toXdrSCVal(),
      b.toXdrSCVal(),
      tokenA.toXdrSCVal(),
      tokenB.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amountA),
      XdrSCVal.forI128BigInt(minBForA),
      XdrSCVal.forI128BigInt(amountB),
      XdrSCVal.forI128BigInt(minAForB),
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'swap',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
  }
  
  /// Builds an AssembledTransaction for the swap method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildSwapTx({
    required Address a,
    required Address b,
    required Address tokenA,
    required Address tokenB,
    required BigInt amountA,
    required BigInt minBForA,
    required BigInt amountB,
    required BigInt minAForB,
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
      a.toXdrSCVal(),
      b.toXdrSCVal(),
      tokenA.toXdrSCVal(),
      tokenB.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amountA),
      XdrSCVal.forI128BigInt(minBForA),
      XdrSCVal.forI128BigInt(amountB),
      XdrSCVal.forI128BigInt(minAForB),
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'swap',
      args: args,
      methodOptions: methodOptions,
    );
  }
}