// This file was generated by stellar_contract_bindings v0.5.0b0 and stellar_sdk v13.0.0.

import 'dart:typed_data';
import 'package:stellar_flutter_sdk/stellar_flutter_sdk.dart';

/// TokenContractAllowanceDataKey struct
class TokenContractAllowanceDataKey {
  final Address from;
  final Address spender;

  const TokenContractAllowanceDataKey({
    required this.from,
    required this.spender,
  });

  XdrSCVal toScVal() {
    final fields = <XdrSCMapEntry>[];
    fields.add(XdrSCMapEntry(
      XdrSCVal.forSymbol('from'),
      from.toXdrSCVal(),
    ));
    fields.add(XdrSCMapEntry(
      XdrSCVal.forSymbol('spender'),
      spender.toXdrSCVal(),
    ));
    return XdrSCVal.forMap(fields);
  }

  factory TokenContractAllowanceDataKey.fromScVal(XdrSCVal val) {
    final map = val.map!;
    final fieldsMap = <String, XdrSCVal>{};
    for (final entry in map) {
      fieldsMap[entry.key.sym!.toString()] = entry.val;
    }
    
    return TokenContractAllowanceDataKey(
      from: Address.fromXdrSCVal(fieldsMap["from"]!),
      spender: Address.fromXdrSCVal(fieldsMap["spender"]!),
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TokenContractAllowanceDataKey &&
          from == other.from &&
          spender == other.spender;

  @override
  int get hashCode => Object.hash(
      from,
      spender
  );
}

/// TokenContractAllowanceValue struct
class TokenContractAllowanceValue {
  final BigInt amount;
  final int expirationLedger;

  const TokenContractAllowanceValue({
    required this.amount,
    required this.expirationLedger,
  });

  XdrSCVal toScVal() {
    final fields = <XdrSCMapEntry>[];
    fields.add(XdrSCMapEntry(
      XdrSCVal.forSymbol('amount'),
      XdrSCVal.forI128BigInt(amount),
    ));
    fields.add(XdrSCMapEntry(
      XdrSCVal.forSymbol('expiration_ledger'),
      XdrSCVal.forU32(expirationLedger),
    ));
    return XdrSCVal.forMap(fields);
  }

  factory TokenContractAllowanceValue.fromScVal(XdrSCVal val) {
    final map = val.map!;
    final fieldsMap = <String, XdrSCVal>{};
    for (final entry in map) {
      fieldsMap[entry.key.sym!.toString()] = entry.val;
    }
    
    return TokenContractAllowanceValue(
      amount: fieldsMap["amount"]!.toBigInt()!,
      expirationLedger: fieldsMap["expiration_ledger"]!.u32!.uint32,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TokenContractAllowanceValue &&
          amount == other.amount &&
          expirationLedger == other.expirationLedger;

  @override
  int get hashCode => Object.hash(
      amount,
      expirationLedger
  );
}

/// Kind enum for TokenContractDataKey
enum TokenContractDataKeyKind {
  Allowance('Allowance'),
  Balance('Balance'),
  Nonce('Nonce'),
  State('State'),
  Admin('Admin');

  final String value;
  
  const TokenContractDataKeyKind(this.value);
  
  factory TokenContractDataKeyKind.fromValue(String value) {
    return TokenContractDataKeyKind.values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw ArgumentError('Unknown TokenContractDataKeyKind value: $value'),
    );
  }
}

/// TokenContractDataKey union
class TokenContractDataKey {
  final TokenContractDataKeyKind kind;
  final TokenContractAllowanceDataKey? allowance;
  final Address? balance;
  final Address? nonce;
  final Address? state;

  const TokenContractDataKey._({
    required this.kind,
    this.allowance,
    this.balance,
    this.nonce,
    this.state,
  });
  factory TokenContractDataKey.allowance(TokenContractAllowanceDataKey value) {
    return TokenContractDataKey._(
      kind: TokenContractDataKeyKind.Allowance,
      allowance: value,
    );
  }
  factory TokenContractDataKey.balance(Address value) {
    return TokenContractDataKey._(
      kind: TokenContractDataKeyKind.Balance,
      balance: value,
    );
  }
  factory TokenContractDataKey.nonce(Address value) {
    return TokenContractDataKey._(
      kind: TokenContractDataKeyKind.Nonce,
      nonce: value,
    );
  }
  factory TokenContractDataKey.state(Address value) {
    return TokenContractDataKey._(
      kind: TokenContractDataKeyKind.State,
      state: value,
    );
  }
  factory TokenContractDataKey.admin() {
    return TokenContractDataKey._(kind: TokenContractDataKeyKind.Admin);
  }

  XdrSCVal toScVal() {
    switch (kind) {
      case TokenContractDataKeyKind.Allowance:
        return XdrSCVal.forVec([
          XdrSCVal.forSymbol(kind.value),
          allowance!.toScVal(),
        ]);
      case TokenContractDataKeyKind.Balance:
        return XdrSCVal.forVec([
          XdrSCVal.forSymbol(kind.value),
          balance!.toXdrSCVal(),
        ]);
      case TokenContractDataKeyKind.Nonce:
        return XdrSCVal.forVec([
          XdrSCVal.forSymbol(kind.value),
          nonce!.toXdrSCVal(),
        ]);
      case TokenContractDataKeyKind.State:
        return XdrSCVal.forVec([
          XdrSCVal.forSymbol(kind.value),
          state!.toXdrSCVal(),
        ]);
      case TokenContractDataKeyKind.Admin:
        return XdrSCVal.forVec([XdrSCVal.forSymbol(kind.value)]);
    }
  }

  factory TokenContractDataKey.fromScVal(XdrSCVal val) {
    final vec = val.vec!;
    final kind = TokenContractDataKeyKind.fromValue(vec[0].sym!.toString());
    
    switch (kind) {
      case TokenContractDataKeyKind.Allowance:
        return TokenContractDataKey.allowance(
          TokenContractAllowanceDataKey.fromScVal(vec[1])
        );
      case TokenContractDataKeyKind.Balance:
        return TokenContractDataKey.balance(
          Address.fromXdrSCVal(vec[1])
        );
      case TokenContractDataKeyKind.Nonce:
        return TokenContractDataKey.nonce(
          Address.fromXdrSCVal(vec[1])
        );
      case TokenContractDataKeyKind.State:
        return TokenContractDataKey.state(
          Address.fromXdrSCVal(vec[1])
        );
      case TokenContractDataKeyKind.Admin:
        return TokenContractDataKey.admin();
    }
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! TokenContractDataKey) return false;
    if (kind != other.kind) return false;
    
    switch (kind) {
      case TokenContractDataKeyKind.Allowance:
        return allowance == other.allowance;
      case TokenContractDataKeyKind.Balance:
        return balance == other.balance;
      case TokenContractDataKeyKind.Nonce:
        return nonce == other.nonce;
      case TokenContractDataKeyKind.State:
        return state == other.state;
      case TokenContractDataKeyKind.Admin:
        return true;
    }
  }

  @override
  int get hashCode {
    switch (kind) {
      case TokenContractDataKeyKind.Allowance:
        return Object.hash(kind, allowance);
      case TokenContractDataKeyKind.Balance:
        return Object.hash(kind, balance);
      case TokenContractDataKeyKind.Nonce:
        return Object.hash(kind, nonce);
      case TokenContractDataKeyKind.State:
        return Object.hash(kind, state);
      case TokenContractDataKeyKind.Admin:
        return kind.hashCode;
    }
  }
}

/// TokenContractTokenMetadata struct
class TokenContractTokenMetadata {
  final int decimal;
  final String name;
  final String symbol;

  const TokenContractTokenMetadata({
    required this.decimal,
    required this.name,
    required this.symbol,
  });

  XdrSCVal toScVal() {
    final fields = <XdrSCMapEntry>[];
    fields.add(XdrSCMapEntry(
      XdrSCVal.forSymbol('decimal'),
      XdrSCVal.forU32(decimal),
    ));
    fields.add(XdrSCMapEntry(
      XdrSCVal.forSymbol('name'),
      XdrSCVal.forString(name),
    ));
    fields.add(XdrSCMapEntry(
      XdrSCVal.forSymbol('symbol'),
      XdrSCVal.forString(symbol),
    ));
    return XdrSCVal.forMap(fields);
  }

  factory TokenContractTokenMetadata.fromScVal(XdrSCVal val) {
    final map = val.map!;
    final fieldsMap = <String, XdrSCVal>{};
    for (final entry in map) {
      fieldsMap[entry.key.sym!.toString()] = entry.val;
    }
    
    return TokenContractTokenMetadata(
      decimal: fieldsMap["decimal"]!.u32!.uint32,
      name: fieldsMap["name"]!.str!,
      symbol: fieldsMap["symbol"]!.str!,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TokenContractTokenMetadata &&
          decimal == other.decimal &&
          name == other.name &&
          symbol == other.symbol;

  @override
  int get hashCode => Object.hash(
      decimal,
      name,
      symbol
  );
}

/// Client for interacting with the TokenContract contract
class TokenContract {
  /// The underlying SorobanClient instance
  final SorobanClient _client;

  /// Creates a new TokenContract for the given contract ID
  static Future<TokenContract> forContractId({
    required KeyPair sourceAccountKeyPair,
    required String contractId,
    required Network network,
    required String rpcUrl,
    bool enableServerLogging = false,
  }) async {
    final options = ClientOptions(
      sourceAccountKeyPair: sourceAccountKeyPair,
      contractId: contractId,
      network: network,
      rpcUrl: rpcUrl,
      enableServerLogging: enableServerLogging,
    );
    
    final client = await SorobanClient.forClientOptions(options: options);
    return TokenContract._(client);
  }
  
  /// Private constructor that wraps a SorobanClient
  TokenContract._(this._client);

  /// Gets the contract ID
  String getContractId() => _client.getContractId();

  /// Gets the client options
  ClientOptions getOptions() => _client.getOptions();

  /// Gets the contract specification
  ContractSpec getContractSpec() => _client.getContractSpec();
  
  /// Invokes the initialize method
  Future<void> initialize({
    required Address admin,
    required int decimal,
    required String name,
    required String symbol,
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
      admin.toXdrSCVal(),
      XdrSCVal.forU32(decimal),
      XdrSCVal.forString(name),
      XdrSCVal.forString(symbol),
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'initialize',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
  }
  
  /// Builds an AssembledTransaction for the initialize method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildInitializeTx({
    required Address admin,
    required int decimal,
    required String name,
    required String symbol,
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
      admin.toXdrSCVal(),
      XdrSCVal.forU32(decimal),
      XdrSCVal.forString(name),
      XdrSCVal.forString(symbol),
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'initialize',
      args: args,
      methodOptions: methodOptions,
    );
  }
  
  /// Invokes the mint method
  Future<void> mint({
    required Address to,
    required BigInt amount,
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
      to.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amount),
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'mint',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
  }
  
  /// Builds an AssembledTransaction for the mint method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildMintTx({
    required Address to,
    required BigInt amount,
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
      to.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amount),
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'mint',
      args: args,
      methodOptions: methodOptions,
    );
  }
  
  /// Invokes the set_admin method
  Future<void> setAdmin({
    required Address newAdmin,
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
      newAdmin.toXdrSCVal(),
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'set_admin',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
  }
  
  /// Builds an AssembledTransaction for the set_admin method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildSetAdminTx({
    required Address newAdmin,
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
      newAdmin.toXdrSCVal(),
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'set_admin',
      args: args,
      methodOptions: methodOptions,
    );
  }
  
  /// Invokes the allowance method
  Future<BigInt> allowance({
    required Address from,
    required Address spender,
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
      from.toXdrSCVal(),
      spender.toXdrSCVal(),
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'allowance',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
    return result.toBigInt()!;
  }
  
  /// Builds an AssembledTransaction for the allowance method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildAllowanceTx({
    required Address from,
    required Address spender,
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
      from.toXdrSCVal(),
      spender.toXdrSCVal(),
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'allowance',
      args: args,
      methodOptions: methodOptions,
    );
  }
  
  /// Invokes the approve method
  Future<void> approve({
    required Address from,
    required Address spender,
    required BigInt amount,
    required int expirationLedger,
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
      from.toXdrSCVal(),
      spender.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amount),
      XdrSCVal.forU32(expirationLedger),
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'approve',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
  }
  
  /// Builds an AssembledTransaction for the approve method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildApproveTx({
    required Address from,
    required Address spender,
    required BigInt amount,
    required int expirationLedger,
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
      from.toXdrSCVal(),
      spender.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amount),
      XdrSCVal.forU32(expirationLedger),
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'approve',
      args: args,
      methodOptions: methodOptions,
    );
  }
  
  /// Invokes the balance method
  Future<BigInt> balance({
    required Address id,
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
      id.toXdrSCVal(),
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'balance',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
    return result.toBigInt()!;
  }
  
  /// Builds an AssembledTransaction for the balance method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildBalanceTx({
    required Address id,
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
      id.toXdrSCVal(),
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'balance',
      args: args,
      methodOptions: methodOptions,
    );
  }
  
  /// Invokes the transfer method
  Future<void> transfer({
    required Address from,
    required Address to,
    required BigInt amount,
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
      from.toXdrSCVal(),
      to.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amount),
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'transfer',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
  }
  
  /// Builds an AssembledTransaction for the transfer method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildTransferTx({
    required Address from,
    required Address to,
    required BigInt amount,
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
      from.toXdrSCVal(),
      to.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amount),
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'transfer',
      args: args,
      methodOptions: methodOptions,
    );
  }
  
  /// Invokes the transfer_from method
  Future<void> transferFrom({
    required Address spender,
    required Address from,
    required Address to,
    required BigInt amount,
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
      spender.toXdrSCVal(),
      from.toXdrSCVal(),
      to.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amount),
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'transfer_from',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
  }
  
  /// Builds an AssembledTransaction for the transfer_from method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildTransferFromTx({
    required Address spender,
    required Address from,
    required Address to,
    required BigInt amount,
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
      spender.toXdrSCVal(),
      from.toXdrSCVal(),
      to.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amount),
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'transfer_from',
      args: args,
      methodOptions: methodOptions,
    );
  }
  
  /// Invokes the burn method
  Future<void> burn({
    required Address from,
    required BigInt amount,
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
      from.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amount),
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'burn',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
  }
  
  /// Builds an AssembledTransaction for the burn method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildBurnTx({
    required Address from,
    required BigInt amount,
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
      from.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amount),
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'burn',
      args: args,
      methodOptions: methodOptions,
    );
  }
  
  /// Invokes the burn_from method
  Future<void> burnFrom({
    required Address spender,
    required Address from,
    required BigInt amount,
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
      spender.toXdrSCVal(),
      from.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amount),
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'burn_from',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
  }
  
  /// Builds an AssembledTransaction for the burn_from method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildBurnFromTx({
    required Address spender,
    required Address from,
    required BigInt amount,
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
      spender.toXdrSCVal(),
      from.toXdrSCVal(),
      XdrSCVal.forI128BigInt(amount),
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'burn_from',
      args: args,
      methodOptions: methodOptions,
    );
  }
  
  /// Invokes the decimals method
  Future<int> decimals({
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'decimals',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
    return result.u32!.uint32;
  }
  
  /// Builds an AssembledTransaction for the decimals method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildDecimalsTx({
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'decimals',
      args: args,
      methodOptions: methodOptions,
    );
  }
  
  /// Invokes the name method
  Future<String> name({
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'name',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
    return result.str!;
  }
  
  /// Builds an AssembledTransaction for the name method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildNameTx({
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'name',
      args: args,
      methodOptions: methodOptions,
    );
  }
  
  /// Invokes the symbol method
  Future<String> symbol({
    KeyPair? signer,
    int baseFee = 100,
    int transactionTimeout = 300,
    int submitTimeout = 30,
    bool simulate = true,
    bool restore = true,
    bool force = false,
  }) async {
    final List<XdrSCVal> args = [
    ];
    
    final methodOptions = MethodOptions();
    // You can customize method options here if needed
    
    final result = await _client.invokeMethod(
      name: 'symbol',
      args: args,
      force: force,
      methodOptions: methodOptions,
    );
    return result.str!;
  }
  
  /// Builds an AssembledTransaction for the symbol method.
  /// This is useful if you need to manipulate the transaction before signing and sending.
  Future<AssembledTransaction> buildSymbolTx({
    MethodOptions? methodOptions,
  }) async {
    final List<XdrSCVal> args = [
    ];
    
    return await _client.buildInvokeMethodTx(
      name: 'symbol',
      args: args,
      methodOptions: methodOptions,
    );
  }
}